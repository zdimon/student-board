<h2>ООП. В javascript.</h2>

<p>Объектно-ориентированное программирование (ООП) — это парадигма программирования, которая использует абстракции, чтобы создавать модели, основанные на объектах реального мира. </p>

<p>ООП использует несколько техник из ранее признанных парадигм, включая наследование, полиморфизм и инкапсуляция. </p>

<p>В javascript изначально было применено прототипное программирование.</p>

<h2>Прототипное программирование</h2>

<p>Прототипное программирование — это модель ООП которая не использует классы, а вместо этого сначала выполняет поведение класса и затем использует его повторно (эквивалент наследования в языках на базе классов), декорируя (или расширяя) существующие объекты прототипы. </p>

<p>Принцип ООП заключается в том, чтобы составлять систему из объектов, решающих простые задачи, которые вместе составляют сложную программу. Объект состоит из приватных изменяемых состояний и функций (методов), которые работают с этими состояниями. У объектов есть определение себя (self, this) и поведение, наследуемое от чертежа, т.е. класса (классовое наследование) или других объектов (прототипное наследование).</p>

<p>Наследование — способ сказать, что эти объекты похожи на другие за исключением некоторых деталей. Наследование позволяет ускорить разработку за счёт повторного использования кода.</p>

<h2>Функция - конструктор.</h2>

<p>Выполняется с ключевым словом new и обычно начинается с заглавной буквы.</p>

<pre><code>function test() {
    this.name = 'Dima';
}

var me = new test();
</code></pre>

<p>При вызове с new создается пустой объект и в него забрасываются свойства из this.</p>

<p>Создадим и экспортируем функцию в библиотечном модуле.</p>

<pre><code>export var Animal = function(name: string): void {
    this.name = name;
    this.show = function() {
        console.log('Drawing object..');
    };
}
</code></pre>

<p>Использование в клиентском коде.</p>

<pre><code>import { Animal } from "./lib";

var animal = new Animal('Muhtar');
console.log(animal);
animal.show();
</code></pre>

<p>Мы можем определить метод в прототипе функции, при этом будет экономиться память при наследовании.</p>

<pre><code>export var Animal = function(name: string): void {
    this.name = name;
} 
Animal.prototype.show = function() {
    console.log('Drawing object..');
}
</code></pre>

<p>JS использует дифиренциально наследование, при котором методы не копируются от родителей к потомкам, а вместо этого передается ссылка на метод и потомки имеют скрытую ссылку на методы родителей.</p>

<p>Если теперь создать объект animal.</p>

<pre><code>var animal = new Animal('dog');
</code></pre>

<p>То объект не будет иметь собственного метода show.</p>

<pre><code>animal.hasOwnProperty('show') === false
</code></pre>

<p>И когда мы обращаемся к свойству, которого в объекте нет, то JS начинает его искать в цепочке прототипов (у родителя).</p>

<h2>Создание конструктора - наследника. Метод Object.create()</h2>

<p>При вызове такого метода.</p>

<pre><code> var parent = {
 foo: function() {
 console.log(‘bar’);
 }
};
var child = Object.create( parent );
child.hasOwnProperty(‘foo’); // false
child.foo(); // ‘bar’
</code></pre>

<p>Создается новый пустой обьект и в его прототип помещается parent.</p>

<p>Таким образом мы можем описать функцию-конструктор Dog с новыми свойствами и перетянув свойства конструктора Animal.</p>

<pre><code>export var Dog = function (name: string): void {
    this.bite = function(){
        console.log('Biting');
    }
    Animal.call(this,name);
}
</code></pre>

<p>А затем связать их по прототипу.</p>

<pre><code>Dog.prototype = Object.create(Animal.prototype);
</code></pre>

# Функции.

При составлении компьютерных программ возникают ситуации, когда определенный набор действий
приходится повторять в разных частях одной программы
или в нескольких разных программах.

При этом в ряде случаев в действия нужно «подставить» новые данные,
а иногда и полностью повторить весь код.

Для того чтобы реализовать такую возможность был
разработан механизм функций.

В программировании
функциями называют отдельные самостоятельные фрагменты кода, которые могут быть вызваны в разных местах
основной программы (или в других функциях) при помощи
ссылки на их имя. Единожды составив и настроив код,
выполняющий некоторое действие (подготовив шаблон),
мы можем оформить его в виде функции и свободно
использовать в произвольных местах, в которых нужно
воспользоваться этим кодом.

Например, диалоговые окна
(alert, prompt и confirm) являются типичными их предста-
вителями.

Инструкции функции «alert» рисуют окно и выводят
в него запомненное при вызове значение «х» (подставляют в шаблон конкретные данные). 
После чего ожидают
закрытия окна пользователем. Подпрограмма заканчивается, и интерпретатор возвращается к тому месту, откуда
произошел ее вызов. Этот процесс называется возврат из
функции (function return).

![start page]({path-to-subject}/images/1.png)

При возврате интерпретатор также может «запомнить»
некоторые данные, которые следует передать из функции
в основную программу. Например, когда нам был нужен
пользовательский ввод, мы использовали инструкцию

    x = prompt("Input x=")


## Синтаксис объявления функции

Пользовательские функции создаются при помощи
ключевого слова «function». Синтаксис объявления функции имеет следующий вид:

    function nameOfFunction(argument1, argument2){
        body
    }

Рассмотрим в качестве примера функцию, создающую 5 однотипных блоков-заголовков (<h2></h2>)
с надписями Header 1 ... Header 5.

    <!doctype html>
    <html>
        <head>
        </head>
        <body>
            <script>
                function show5Blocks() {
                    for(i=1;i<=5;i++)
                    document.write("<h2> Header "+i+
                    "</h2>");
                }
                show5Blocks();
            </script>
        </body>
    </html>

![start page]({path-to-subject}/images/2.png)

## Параметры функции

Передаваемые из программы данные
называются «аргументами», а со стороны функции эти
данные принимаются как «параметры».

Приготовим новый файл.

    <!doctype html>
    <html>
        <head>
        </head>
        <body>
            <p id="Log"></p>
            <script>
            </script>
        </body>
    </html>

В котором есть один элемент p с идентификатором Log.

Теперь определим функцию в разделе <script> 

    function incAndLog(x) {
        x = x+1;
        alert("inc x = " + x);
        Log.innerHTML += "<br>inc x = " + x;
    }

К элементу с идентификатором можно обратиться по имени идентификатора.

Теперь после функции объявим переменную и вызовим функцию, передав в нее эту переменную в качестве парамтра.

    x = 2;
    incAndLog(x);

Процесс выполнения.

![start page]({path-to-subject}/images/4.png)

## Возвращаемое значение функции.
### Ключевое слово return


Для обеспечения обратного потока данных, — из
функции в основную программу, — применяется механизм возврата значений.

В объявлении функции для возврата значения используется ключевое слово «return», после которого указываются передаваемые из функции данные.

Рассмотрим пример: необходимо создать функцию,
вычисляющую куб переданного аргумента.

    function cube(x) {
        return x*x*x;
    }

Вызов функции с присвоением результата переменной.

    y = cube(2)

Вызов функции в расчете.

    2 * cube(2)

Вызов функции при передачи ее результата в качестве аргумента другой функции.

    alert( cube(2) )

![start page]({path-to-subject}/images/5.png)

## Объект arguments

При вызове функции все переданные в нее аргументы
попадают в специальный объект «arguments», доступный
для использования в теле функции.

Создадим функцию
«logArguments», задача которой будет вывод в консоль
значения принятого в теле функции объекта «arguments».

    function logArguments(){
        console.log(arguments);
    }

Затем несколько раз вызовем эту функцию, указав
различное количество аргументов. Вводим в консоль,
последовательно нажимая «Enter»

    logArguments(1,2,3)
    logArguments("text")

![start page]({path-to-subject}/images/6.png)



Как видно, в первом случае в объекте «arguments»
наблюдаются три переданных числа 1, 2 и 3, идущие под
индексами 0, 1 и 2 соответственно. Во втором случае
в объекте присутствует строка «text» с индексом 0. 

По указанным индексам в функции можно получить данные обо всех переданных аргументах, независимо от их
количества. 

Например, выражение «arguments[0]» будет
отвечать за первый аргумент, переданный в функцию:
число 1 в первом вызове или строку «text» — во втором.
Выражение «arguments[1]» обеспечит доступ ко второму
аргументу и так далее.

### Свойство length

Cвойство «length» отвечает за количество переданных
в функцию аргументов.

Мы можем его использовать для организации цикла по переданным аргументам.

    function logArguments(){
        for(i=0; i<arguments.length; i++) {
            console.log("argument"+(i+1)+" = "+arguments[i])
        }
    }

Подобным образом в любой функции можно узнать
как об общем количестве переданных аргументов, так
и об их значениях.

Реализуем функцию, возвращающую наибольший аргумент.

    function max(){
        if(arguments.length == 0) return undefined;
        ret = arguments[0];
        for(i=1;i<arguments.length;i++) {
            if(arguments[i]>ret) {
                ret = arguments[i];
            }
        }
        return ret;
    }

Тут в переменную «ret» записываем значение первого
аргумента. Затем циклически сравниваем это значение
с каждым из аргументов и, если значение аргумента окажется большим, чем хранимое, то заменяем это хранимое
значение на новое. 

По завершению цикла возвращаем
полученный в переменной «ret» результат.

В JavaScript  любая функция может принять произвольное количество
аргументов, независимо от того, сколько их было указано
при объявлении функции. Это значительно упрощает
разработку и сокращает количество кода, поскольку не
требует переопределения разных функций для разных
наборов данных.

Обратная сторона этой возможности заключается в том,
что в JavaScript все функции, имеющие одинаковые имена,
даже при разном наборе параметров, являются по сути
одним и тем же объектом.

Попытка объявить функцию
с именем уже существующей функции, но с указанием
другого числа параметров приведет к переопределению
функции — существующая функция будет полностью
заменена на новую.

В JavaScript следует крайне внимательно следить за
выбором имен переменных и функций!

Так как такой код может привести к неожиданным результатам.

    function parity(x) {
        if(x % 2 == 0) {
            parity = "even";
        }
        else {
            parity = "odd";
        }
    }

Т.к. после первого вызова функции
с любым аргументом, имя «parity» будет переопределено
телом функции как переменная и, вместо функции, она
будет хранить строку «even» или «odd» в зависимости от
переданного значения «х».

## Область видимости переменной

Одной из особенностей составления программ, отличающейся для разных языков программирования, является понятие «области видимости» переменных, ее границ
и возможностей. Областью видимости переменной называют участок программы, в котором возможен доступ
к данной переменной по ее имени.

Определим и вызовем такую функцию:

    x = 1;
    function logX(){
        console.log(x);
    }


Как следует из приведенного примера, функция «logX()»
имеет доступ к переменной, описанной вне этой функции.

С точки зрения тела функции, эта переменная является
глобальной, то есть объявленной во внешнем блоке кода,
вызвавшем функцию, но остающейся доступной в текущем блоке (в функции). Обеспечивает такую видимость
переменных специальный объект, называемый глобальным. В JavaScript роль глобального объекта играет объект
«window».

Понятие глобального объекта распространяется
только на одну вкладку браузера.

Эффект, связанный с изменением значений глобальных переменных в результате
работы функции носит название «побочного действия
функции». В некоторых случаях это используется для
обмена данными между различными функциями, но
может носить и нежелательный характер.


Для того чтобы создать локальную
переменную используется ключевое слово «var» перед
именем переменной. Начиная со стандарта «ES6» также
можно использовать «let». Инструкции «var» и «let» могут
использоваться сами по себе (для декларации локальных
переменных), а также в составе оператора присваивания:

    var a;
    let b = 1;

Локальные переменные имеют приоритет перед глобальными. Другими словами, если локальная и глобальная
переменные имеют одинаковые имена, то в данном блоке
будет использована локальная переменная.

Для того, чтобы устранить эффект побочного действия для цикла внутри функции и не дать переменной i попасть в глобальное пространство нужно использовать var или let.

    for(var i=0; i<arguments.length; i++)

## Поднятие объявлений

Отличительной особенностью JavaScript, по сравнению со многими другими языками программирования,
является принцип поднятия объявлений (англ. hoisting).
Заключается он в том, что перед выполнением программы
все объявления функций и переменных «поднимаются»
в начало программы или, точнее, в начало своей области
видимости. И только затем код выполняется.


Рассмотрим пример: создадим функцию, в которой
дважды выводится содержимое переменной «х» — до
и после её объявления.


    function showHoisting(){
        console.log("x before declaration: "+x);
        var x = 2;
        console.log("x after declaration: "+x);
    }

![start page]({path-to-subject}/images/7.png)

В данном случае мы наблюдаем значение «undefined», выведенное без ошибки.

Повторим вызов функции, только перед этим создадим глобальную переменную «х» со значением 1 (введем
в консоли х=1). По логике, до объявления «var x» в теле
функции под переменной «х» должна пониматься ее
глобальная тезка. Но повторный вызов функции все так
же дает «undefined» вместо ожидаемой единицы.
Полученные результаты иллюстрируют эффект, связанный с работой поднятия объявлений.

Благодаря ему
инструкция «var x» перед выполнением функции переносится в самое начало функции, и первая операция
«console.log("x before declaration: "+x);» на самом деле
становится второй.

## Различия деклараций var, let и const

Очередной особенностью JavaScript, по сравнению
с другими языками программирования, является слабое
структурирование областей видимости. Во многих языках каждый блок кода, заключенный в группирующий
оператор, является собственной областью видимости.
Переменные, описанные в разных блоках, при этом не
взаимодействуют между собой, даже если имеют одинаковые имена.

В JavaScript отдельные области видимости создаются
только внутри функций и действуют в пределах их тел.

Другие блоки, циклы или условные операторы внутри одной
функции используют локальную область самой функции.

Например, объявленная в цикле переменная становится доступной и вне тела цикла. Причем доступной как
после цикла, так и до него — с самого начала функции
(или всей программы, если цикл описан в ней).

    // here i does exist
    for(var i=0; i<arguments.length; i++) { // here i
        // exists normally
    }
    // and here i still exists

Для того чтобы уменьшить количество ошибок, связанных с наличием у программиста предыдущего опыта,
и сделать JavaScript более дружественным для таких программистов начиная со стандарта «ES6» было
введено ключевое слово «let».

Переменная, объявленная
с этим декларатором, становится доступной (локальной)
только для того блока, в котором она описана (как это
принято в других языках программирования).

    // here i does not exist
    for(let i=0; i<arguments.length; i++){
        // here i exists
    }
    // and here i does not exist

Также переменная, объявленная оператором «let», не
может быть повторно определена ни оператором «let», ни
оператором «var».

Упредить ошибки, связанные со случайным изменением
значения переменной, можно при помощи ее объявления
с ключевым словом «const»

Объявленные с этим ключевым словом переменные:

- являются видимыми только в «своем» блоке.

- не могут быть повторно объявлены другим оператором
(«var», «let» или «const») в дальнейшем коде данного
блока.

- приведут к ошибке объявления, если в данном блоке
ранее были объявлены другим оператором («var», «let»
или «const») переменные с таким же именем.

- не могут менять свое значение повторным присваива-
нием (возможно только одно присваивание значения
переменной).

## Рекурсия

Рекурсией называют ситуацию, в которой
функция вызывает сама себя.

Функция для расчета факториала:

    function factorial(n){
        if(n==1) { 
            return 1;
        }
        return n*factorial(n-1);
    }


<h1>Функции.</h1>

<p>При составлении компьютерных программ возникают ситуации, когда определенный набор действий
приходится повторять в разных частях одной программы
или в нескольких разных программах.</p>

<p>При этом в ряде случаев в действия нужно «подставить» новые данные,
а иногда и полностью повторить весь код.</p>

<p>Для того чтобы реализовать такую возможность был
разработан механизм функций.</p>

<p>В программировании
функциями называют отдельные самостоятельные фрагменты кода, которые могут быть вызваны в разных местах
основной программы (или в других функциях) при помощи
ссылки на их имя. Единожды составив и настроив код,
выполняющий некоторое действие (подготовив шаблон),
мы можем оформить его в виде функции и свободно
использовать в произвольных местах, в которых нужно
воспользоваться этим кодом.</p>

<p>Например, диалоговые окна
(alert, prompt и confirm) являются типичными их предста-
вителями.</p>

<p>Инструкции функции «alert» рисуют окно и выводят
в него запомненное при вызове значение «х» (подставляют в шаблон конкретные данные). 
После чего ожидают
закрытия окна пользователем. Подпрограмма заканчивается, и интерпретатор возвращается к тому месту, откуда
произошел ее вызов. Этот процесс называется возврат из
функции (function return).</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/4-func/images/1.png" alt="start page" /></p>

<p>При возврате интерпретатор также может «запомнить»
некоторые данные, которые следует передать из функции
в основную программу. Например, когда нам был нужен
пользовательский ввод, мы использовали инструкцию</p>

<pre><code>x = prompt("Input x=")
</code></pre>

<h2>Синтаксис объявления функции</h2>

<p>Пользовательские функции создаются при помощи
ключевого слова «function». Синтаксис объявления функции имеет следующий вид:</p>

<pre><code>function nameOfFunction(argument1, argument2){
    body
}
</code></pre>

<p>Рассмотрим в качестве примера функцию, создающую 5 однотипных блоков-заголовков (<h2></h2>)
с надписями Header 1 ... Header 5.</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
            function show5Blocks() {
                for(i=1;i&lt;=5;i++)
                document.write("&lt;h2&gt; Header "+i+
                "&lt;/h2&gt;");
            }
            show5Blocks();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><img src="https://webmonstr.com/media/course/frontend-js/4-func/images/2.png" alt="start page" /></p>

<h2>Параметры функции</h2>

<p>Передаваемые из программы данные
называются «аргументами», а со стороны функции эти
данные принимаются как «параметры».</p>

<p>Приготовим новый файл.</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p id="Log"&gt;&lt;/p&gt;
        &lt;script&gt;
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>В котором есть один элемент p с идентификатором Log.</p>

<p>Теперь определим функцию в разделе <script> </p>

<pre><code>function incAndLog(x) {
    x = x+1;
    alert("inc x = " + x);
    Log.innerHTML += "&lt;br&gt;inc x = " + x;
}
</code></pre>

<p>К элементу с идентификатором можно обратиться по имени идентификатора.</p>

<p>Теперь после функции объявим переменную и вызовим функцию, передав в нее эту переменную в качестве парамтра.</p>

<pre><code>x = 2;
incAndLog(x);
</code></pre>

<p>Процесс выполнения.</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/4-func/images/4.png" alt="start page" /></p>

<h2>Возвращаемое значение функции.</h2>

<h3>Ключевое слово return</h3>

<p>Для обеспечения обратного потока данных, — из
функции в основную программу, — применяется механизм возврата значений.</p>

<p>В объявлении функции для возврата значения используется ключевое слово «return», после которого указываются передаваемые из функции данные.</p>

<p>Рассмотрим пример: необходимо создать функцию,
вычисляющую куб переданного аргумента.</p>

<pre><code>function cube(x) {
    return x*x*x;
}
</code></pre>

<p>Вызов функции с присвоением результата переменной.</p>

<pre><code>y = cube(2)
</code></pre>

<p>Вызов функции в расчете.</p>

<pre><code>2 * cube(2)
</code></pre>

<p>Вызов функции при передачи ее результата в качестве аргумента другой функции.</p>

<pre><code>alert( cube(2) )
</code></pre>

<p><img src="https://webmonstr.com/media/course/frontend-js/4-func/images/5.png" alt="start page" /></p>

<h2>Объект arguments</h2>

<p>При вызове функции все переданные в нее аргументы
попадают в специальный объект «arguments», доступный
для использования в теле функции.</p>

<p>Создадим функцию
«logArguments», задача которой будет вывод в консоль
значения принятого в теле функции объекта «arguments».</p>

<pre><code>function logArguments(){
    console.log(arguments);
}
</code></pre>

<p>Затем несколько раз вызовем эту функцию, указав
различное количество аргументов. Вводим в консоль,
последовательно нажимая «Enter»</p>

<pre><code>logArguments(1,2,3)
logArguments("text")
</code></pre>

<p><img src="https://webmonstr.com/media/course/frontend-js/4-func/images/6.png" alt="start page" /></p>

<p>Как видно, в первом случае в объекте «arguments»
наблюдаются три переданных числа 1, 2 и 3, идущие под
индексами 0, 1 и 2 соответственно. Во втором случае
в объекте присутствует строка «text» с индексом 0. </p>

<p>По указанным индексам в функции можно получить данные обо всех переданных аргументах, независимо от их
количества. </p>

<p>Например, выражение «arguments[0]» будет
отвечать за первый аргумент, переданный в функцию:
число 1 в первом вызове или строку «text» — во втором.
Выражение «arguments[1]» обеспечит доступ ко второму
аргументу и так далее.</p>

<h3>Свойство length</h3>

<p>Cвойство «length» отвечает за количество переданных
в функцию аргументов.</p>

<p>Мы можем его использовать для организации цикла по переданным аргументам.</p>

<pre><code>function logArguments(){
    for(i=0; i&lt;arguments.length; i++) {
        console.log("argument"+(i+1)+" = "+arguments[i])
    }
}
</code></pre>

<p>Подобным образом в любой функции можно узнать
как об общем количестве переданных аргументов, так
и об их значениях.</p>

<p>Реализуем функцию, возвращающую наибольший аргумент.</p>

<pre><code>function max(){
    if(arguments.length == 0) return undefined;
    ret = arguments[0];
    for(i=1;i&lt;arguments.length;i++) {
        if(arguments[i]&gt;ret) {
            ret = arguments[i];
        }
    }
    return ret;
}
</code></pre>

<p>Тут в переменную «ret» записываем значение первого
аргумента. Затем циклически сравниваем это значение
с каждым из аргументов и, если значение аргумента окажется большим, чем хранимое, то заменяем это хранимое
значение на новое. </p>

<p>По завершению цикла возвращаем
полученный в переменной «ret» результат.</p>

<p>В JavaScript  любая функция может принять произвольное количество
аргументов, независимо от того, сколько их было указано
при объявлении функции. Это значительно упрощает
разработку и сокращает количество кода, поскольку не
требует переопределения разных функций для разных
наборов данных.</p>

<p>Обратная сторона этой возможности заключается в том,
что в JavaScript все функции, имеющие одинаковые имена,
даже при разном наборе параметров, являются по сути
одним и тем же объектом.</p>

<p>Попытка объявить функцию
с именем уже существующей функции, но с указанием
другого числа параметров приведет к переопределению
функции — существующая функция будет полностью
заменена на новую.</p>

<p>В JavaScript следует крайне внимательно следить за
выбором имен переменных и функций!</p>

<p>Так как такой код может привести к неожиданным результатам.</p>

<pre><code>function parity(x) {
    if(x % 2 == 0) {
        parity = "even";
    }
    else {
        parity = "odd";
    }
}
</code></pre>

<p>Т.к. после первого вызова функции
с любым аргументом, имя «parity» будет переопределено
телом функции как переменная и, вместо функции, она
будет хранить строку «even» или «odd» в зависимости от
переданного значения «х».</p>

<h2>Область видимости переменной</h2>

<p>Одной из особенностей составления программ, отличающейся для разных языков программирования, является понятие «области видимости» переменных, ее границ
и возможностей. Областью видимости переменной называют участок программы, в котором возможен доступ
к данной переменной по ее имени.</p>

<p>Определим и вызовем такую функцию:</p>

<pre><code>x = 1;
function logX(){
    console.log(x);
}
</code></pre>

<p>Как следует из приведенного примера, функция «logX()»
имеет доступ к переменной, описанной вне этой функции.</p>

<p>С точки зрения тела функции, эта переменная является
глобальной, то есть объявленной во внешнем блоке кода,
вызвавшем функцию, но остающейся доступной в текущем блоке (в функции). Обеспечивает такую видимость
переменных специальный объект, называемый глобальным. В JavaScript роль глобального объекта играет объект
«window».</p>

<p>Понятие глобального объекта распространяется
только на одну вкладку браузера.</p>

<p>Эффект, связанный с изменением значений глобальных переменных в результате
работы функции носит название «побочного действия
функции». В некоторых случаях это используется для
обмена данными между различными функциями, но
может носить и нежелательный характер.</p>

<p>Для того чтобы создать локальную
переменную используется ключевое слово «var» перед
именем переменной. Начиная со стандарта «ES6» также
можно использовать «let». Инструкции «var» и «let» могут
использоваться сами по себе (для декларации локальных
переменных), а также в составе оператора присваивания:</p>

<pre><code>var a;
let b = 1;
</code></pre>

<p>Локальные переменные имеют приоритет перед глобальными. Другими словами, если локальная и глобальная
переменные имеют одинаковые имена, то в данном блоке
будет использована локальная переменная.</p>

<p>Для того, чтобы устранить эффект побочного действия для цикла внутри функции и не дать переменной i попасть в глобальное пространство нужно использовать var или let.</p>

<pre><code>for(var i=0; i&lt;arguments.length; i++)
</code></pre>

<h2>Поднятие объявлений</h2>

<p>Отличительной особенностью JavaScript, по сравнению со многими другими языками программирования,
является принцип поднятия объявлений (англ. hoisting).
Заключается он в том, что перед выполнением программы
все объявления функций и переменных «поднимаются»
в начало программы или, точнее, в начало своей области
видимости. И только затем код выполняется.</p>

<p>Рассмотрим пример: создадим функцию, в которой
дважды выводится содержимое переменной «х» — до
и после её объявления.</p>

<pre><code>function showHoisting(){
    console.log("x before declaration: "+x);
    var x = 2;
    console.log("x after declaration: "+x);
}
</code></pre>

<p><img src="https://webmonstr.com/media/course/frontend-js/4-func/images/7.png" alt="start page" /></p>

<p>В данном случае мы наблюдаем значение «undefined», выведенное без ошибки.</p>

<p>Повторим вызов функции, только перед этим создадим глобальную переменную «х» со значением 1 (введем
в консоли х=1). По логике, до объявления «var x» в теле
функции под переменной «х» должна пониматься ее
глобальная тезка. Но повторный вызов функции все так
же дает «undefined» вместо ожидаемой единицы.
Полученные результаты иллюстрируют эффект, связанный с работой поднятия объявлений.</p>

<p>Благодаря ему
инструкция «var x» перед выполнением функции переносится в самое начало функции, и первая операция
«console.log("x before declaration: "+x);» на самом деле
становится второй.</p>

<h2>Различия деклараций var, let и const</h2>

<p>Очередной особенностью JavaScript, по сравнению
с другими языками программирования, является слабое
структурирование областей видимости. Во многих языках каждый блок кода, заключенный в группирующий
оператор, является собственной областью видимости.
Переменные, описанные в разных блоках, при этом не
взаимодействуют между собой, даже если имеют одинаковые имена.</p>

<p>В JavaScript отдельные области видимости создаются
только внутри функций и действуют в пределах их тел.</p>

<p>Другие блоки, циклы или условные операторы внутри одной
функции используют локальную область самой функции.</p>

<p>Например, объявленная в цикле переменная становится доступной и вне тела цикла. Причем доступной как
после цикла, так и до него — с самого начала функции
(или всей программы, если цикл описан в ней).</p>

<pre><code>// here i does exist
for(var i=0; i&lt;arguments.length; i++) { // here i
    // exists normally
}
// and here i still exists
</code></pre>

<p>Для того чтобы уменьшить количество ошибок, связанных с наличием у программиста предыдущего опыта,
и сделать JavaScript более дружественным для таких программистов начиная со стандарта «ES6» было
введено ключевое слово «let».</p>

<p>Переменная, объявленная
с этим декларатором, становится доступной (локальной)
только для того блока, в котором она описана (как это
принято в других языках программирования).</p>

<pre><code>// here i does not exist
for(let i=0; i&lt;arguments.length; i++){
    // here i exists
}
// and here i does not exist
</code></pre>

<p>Также переменная, объявленная оператором «let», не
может быть повторно определена ни оператором «let», ни
оператором «var».</p>

<p>Упредить ошибки, связанные со случайным изменением
значения переменной, можно при помощи ее объявления
с ключевым словом «const»</p>

<p>Объявленные с этим ключевым словом переменные:</p>

<ul>
<li><p>являются видимыми только в «своем» блоке.</p></li>
<li><p>не могут быть повторно объявлены другим оператором
(«var», «let» или «const») в дальнейшем коде данного
блока.</p></li>
<li><p>приведут к ошибке объявления, если в данном блоке
ранее были объявлены другим оператором («var», «let»
или «const») переменные с таким же именем.</p></li>
<li><p>не могут менять свое значение повторным присваива-
нием (возможно только одно присваивание значения
переменной).</p></li>
</ul>

<h2>Рекурсия</h2>

<p>Рекурсией называют ситуацию, в которой
функция вызывает сама себя.</p>

<p>Функция для расчета факториала:</p>

<pre><code>function factorial(n){
    if(n==1) { 
        return 1;
    }
    return n*factorial(n-1);
}
</code></pre>

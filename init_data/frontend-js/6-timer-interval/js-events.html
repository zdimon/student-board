<h1>События.</h1>

<p>Внутри компьютера все время происходят события, которые могут изходить как от самого пользователя (нажатие на клавиатуру), так и от программ.</p>

<p>Задача компьютера (операционной системы) - как можно быстрее реагировать на такие события и запускать соответствующие им программы (обработчики).</p>

<p>В ОС такие события называются прерываниями, в js - событиями.</p>

<p>Обычно, обработчики событий — это отдельные функции.</p>

<p>Работа системы событий связано с понятием сообщений.</p>

<p>Сообщение - это информация о том, что в системе произошла какое то событие.</p>

<p>Операционная система имеет свой набор стандартных сообщений, например, движение мыши или нажатие
ее клавиш, переключение между окнами, изменение их
размеров или положения, нажатие кнопок клавиатуры
и т.д. Прикладные программы могут создавать другие
(дополнительные) сообщения.</p>

<p>Например, браузеры дополняют системные сообщения собственным набором,
необходимым именно для веб-страниц.</p>

<p>Обработка сообщения, принятие решение о его типе,
анализ дополнительных данных уже называется событием.</p>

<p>Все сообщения поступают в очередь сообщений, эту очередь обслуживает специальный программный цикл - цикл событий (жизненный цикл).</p>

<p>Который в цикле выбирает сообщения, обрабатывает определенное
сообщение (тогда и возникает событие) и запускает его обработчик.</p>

<p>Если для события обработчика нет, то такое сообщение просто
игнорируется и удаляется из очереди.</p>

<p>В JavaScript принято обращаться к собы-
тиям по их именам (в операционной системе — по кодам).</p>

<p><a href="https://www.w3schools.com/jsref/dom_obj_event.asp">полный список событий браузера</a></p>

<p>В качестве обобщения события можно условно
разделить на несколько групп:</p>

<ul>
<li><p>События интерфейса пользователя;</p></li>
<li><p>События жизненного цикла;</p></li>
<li><p>Индивидуальные события.</p></li>
</ul>

<p>События интерфейса пользователя возникают за счет
активности пользователя веб-страницы.</p>

<p>События жизненного цикла посылаются элементам
при их создании, загрузке, в том числе ошибках загрузки,
при получении системных сообщений, переходу в online
или offline режим, запуске анимации и т.п</p>

<p>Индивидуальные события характерны только для
определенных объектов и для объектов другого типа не
используются. Примером может быть событие «pause»,
возникающее при остановке воспроизведения (паузе)
медиа-контента. Очевидно, что это событие касается
только медиа-контейнеров.</p>

<h2>Обработка событий в сценариях</h2>

<p>Для всех стандартных событий у элементов страницы
предусмотрены обработчики. Традиционно их имена формируются из префикса «on» и имени события.
Например, обработчик события щелчка мыши «click» будет иметь
название «onclick».</p>

<p>Существует несколько способов определить тело для
обработчика событий.</p>

<ol>
<li><p>Указать его как HTML-атрибут при объявлении элемента</p>

<div onclick="alert('DIV have been clicked')"></div></li>
<li><p>Определить обработчик события в скриптовой части кода.</p>

<div id="clickableDiv"></div>

<script>
    clickableDiv.onclick=function(){
     alert('DIV have been clicked')
    }
</script></li>
</ol>

<p>При этом по идентификатору создается одноименный объект.</p>

<ol>
<li><p>Задать обработчик события для элемента — это применить специальный метод «addEventListener».</p>

<script>
    clickableDiv.addEventListener("click", function(){
        alert('DIV have been clicked')
    })
</script></li>
</ol>

<p>Обратите внимание, в данном
случае передается имя события «click» (без префикса «on»,
используемого для имени обработчика).</p>

<h1>Объект event и его свойства</h1>

<p>При обработке события часто бывает необходима дополнительная информация, связанная с возникновением
самого события.</p>

<p>При обработке системного сообщения и создании
программного события браузер формирует специальный
объект «event», в котором собираются все данные о событии.</p>

<p>Информация в объекте «event» зависит от типа события,
которое обрабатывается.</p>

<p>Еее можно разделить на ту, которая присуща всем событиям, например объект target, в котором находится целевой объект события. И информацию, присущую конкретному событию например данные о кнопке клавиатуры, или координаты указателя мыши.</p>

<p>Пример обработки события.</p>

<pre><code>&lt;body onclick = "out.innerText = 'Click detected over: ' + event.target.nodeName"&gt;
</code></pre>

<p>Т.к. мы поместили обработчик в тег body, то он будет срабатывать при нажатии на любой элемент на странице.</p>

<p>Таким образом событие "всплывает" наверх. Но объект target будет содержать тот элемент, на котором кликнули.</p>

<p>Как выглядит обьект события в консоле.</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/6-timer-interval/images/1.png" alt="start page" /></p>

<p>Некоторые стандартизированные значения.</p>

<ul>
<li><p>screenX, screenY — координаты курсора относительно экрана монитора;</p></li>
<li><p>pageX, pageY — координаты относительно начала веб-страницы;</p></li>
<li><p>clientX, clientY — координаты относительно клиентской части окна браузера.</p></li>
</ul>

<p>Так же в событии присутствуют координаты элемента относительно родителя.</p>

<p>Событие передается в функцию-обработчик в качестве параметра.</p>

<pre><code>element.onclick = function(e){...}
</code></pre>

<p>Обычно событие называют  e или evt.</p>

<h2>Управление стилями элементов web-страницы</h2>

<p>Осуществляется установкой свойства style объекта.</p>

<pre><code>function moveStranger(e){
    stranger.style.left=e.pageX+'px';
    stranger.style.top =e.pageY+'px';
}
</code></pre>

<p>Можно через индекс массива.</p>

<pre><code>element.style["left"]
</code></pre>

<p>При этом т.к. -  это знак вычитания и element.style.background-сolor недопустим, то используется верблюжья нотация.</p>

<pre><code>element.style["background-color"] = element.style.backgroundColor
</code></pre>

<h2>Движение мышкой.</h2>

<p>Отличие событий mouseenter от mouseover.</p>

<p>Различие между этими событиями заключается в том,
что события «mouseenter» и «mouseleave» получает только
самый «верхний» элемент, тогда как другая пара событий
«mouseover» и «mouseout» передается всем элементам, находящимся под курсором мыши.</p>

<p>Данный эффект называется всплытием событий (англ. bubbling или propagation).</p>

<p>Предположим есть 2 вложенных блока.</p>

<p>Событие «onmouseover» приходит дважды - сначала от блока «d2», затем от «d1».</p>

<p>Для управления процессом всплытия у событий предназначен
метод «stopPropagation».</p>

<pre><code>div1.addEventListener("click",function(e){
    console.log('Click on div1'); 
    e.stopPropagation()
})
</code></pre>

<p>Пример реализации функции Drug and Drop.</p>

<pre><code>&lt;style&gt;
body{
    position: relative;
    }
    #div1 {
    background-color: tomato;
    border: 1px solid red;
    border-radius: 50%;
    height: 100px;
    width: 100px;
    position: absolute;
}
&lt;/style&gt;



&lt;div id="div1"&gt;&lt;/div&gt;
&lt;script&gt;
    var isDrag = false;

    div1.addEventListener("mousedown",
        function(){ isDrag = true }
    )

    document.addEventListener("mouseup",
        function(){ isDrag = false }
    )

    document.addEventListener("mousemove",
        function(e){
            if(isDrag){
                div1.style.left = e.pageX + "px";
                div1.style.top = e.pageY + "px";
            }
        }
    )
&lt;/script&gt;
</code></pre>

<h2>События жизненного цикла</h2>

<p>Когда Вы включаете браузер и открываете в нем новую веб-страницу происходит определенная цепочка
процессов: браузер находит сервер, на котором находится страница, и запрашивает ее HTML код. Получив
ответ, браузер, обрабатывает его и формирует структуру страницы, попутно загружая все элементы (картинки, скрипты и т.д.).</p>

<p>Описанный процесс носит название жизненного цикла веб-страницы.</p>

<p>Жизненный цикл веб-страницы сопровождается следующими событиями</p>

<p><strong>DOMContentLoaded</strong> — браузер полностью загрузил HTML, файлы стилей и скриптов, построил структуру документа (DOM-структуру;</p>

<p><strong>load</strong> — браузер загрузил все дополнительные ресурсы — изображения, фреймы;</p>

<p><strong>beforeunload</strong> — браузер получил команду закрыть страницу (вкладку);</p>

<p><strong>unload</strong> — браузер закрыл страницу (вкладку).</p>

<h3>DOMContentLoaded</h3>

<p>Событие «DOMContentLoaded» является одним
из наиболее популярных среди событий жизненного
цикла. Оно посылается объекту «document» тогда, когда
загружен код HTML, стилевые файлы и скрипты и структура страницы уже определена.</p>

<p>Однако изображения и фреймы могут быть не загружены.</p>

<p>Обработчик события «DOMContentLoaded» подклю-
чается только при помощи команды «addEventListener»:</p>

<pre><code>document.addEventListener( "DOMContentLoaded" ,
    function() {
        alert("DOM loaded")
    }
)
</code></pre>

<p>Использование атрибутов с префиксом «on», как для
большинства других событий, не даст должного эффекта.</p>

<pre><code>document.onDOMContentLoaded = function() {
    alert("DOM loaded")
}
</code></pre>

<h3>load</h3>

<p>Событие «load» посылается после загрузки всех дополнительных ресурсов — изображений, фреймов и т.п.</p>

<p>Данное событие относится к объекту «window» и может
быть обработано всеми допустимыми вариантами — как
при помощи метода «addEventListener», так и указанием
атрибутов с префиксом «on»</p>

<pre><code>&lt;body onload="alert('body loaded')"&gt;
window.onload = function() {alert('body loaded')}
window.addEventListener( "load",
    function() {
        alert('body loaded')
    })
</code></pre>

<p>Следует обратить внимание на то, что загрузка изображений еще не означает их отображение. Событие «load» посылается по факту окончания загрузки, но не по окончанию прорисовки. В большинстве случаев изображения
хранятся в сжатых форматах, и для их вывода на страницу
браузеру необходимо повести «декомпрессию» — восстановление графической информации из сжатого файла.
На это уходит определенное время, которого может не
хватить до вызова обработчика события.</p>

<p>Создадим файл index.html чтобы проследить этапы загрузки.</p>

<pre><code>&lt;!doctype html /&gt;
&lt;html&gt;
&lt;head&gt;

&lt;/head&gt;
&lt;body onload="alert('body loaded')"&gt;
    &lt;img src="step.jpg" /&gt;
&lt;script&gt;
    document.addEventListener("DOMContentLoaded" ,
        function() {
            alert("DOM loaded")
        }
    )
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Первым вызывается событие DOMContentLoaded и изображение еще не загружено и имеет статус pending.</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/6-timer-interval/images/5.png" alt="start page" /></p>

<p>Затем происходит событие onload и изображение загружается.</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/6-timer-interval/images/6.png" alt="start page" /></p>

<p>Поскольку дополнительные ресурсы страницы загружаются отдельно от HTML кода, для них также посылаются
события об итоговом статусе. Такими событиями являются
«load» и «error».</p>

<p>Пример отслеживания таких событий для изображения.</p>

<pre><code>&lt;img src="step.jpg"
onload="addMessage('step.jpg load OK')"
onerror="addMessage('step.jpg load error')"/&gt;

&lt;p id="txt"&gt;&lt;/p&gt;
&lt;script&gt;
    function addMessage(msg) {
        window.txt.innerHTML += msg + "&lt;br/&gt;"
    }
&lt;/script&gt;
</code></pre>

<h3>beforeunload</h3>

<p>Событие «beforeunload» посылается окну (объекту
«window») и сигнализирует о начале закрытия (выгрузки,
unload) страницы. На данном этапе можно предупредить
пользователя, что на странице остались несохраненные
данные, незаконченные процессы отправки или получения данных.</p>

<pre><code>&lt;!doctype html /&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;style&gt;
        #text {
        height: 200px;
        width: 400px;
        }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;textarea id="text"&gt;&lt;/textarea&gt;&lt;br/&gt;
        &lt;a href="http://itstep.org"&gt;IT Step&lt;/a&gt;
        66Обработка событий
        &lt;script&gt;
            window.onbeforeunload =
            function(e) {
                if(text.value.length &gt; 0) {
                    var msg = 'Text not saved';
                    e.returnValue = msg;
                    return msg;
                }
                return null;
            }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Принцип работы обработчика заключается в том, что он должен вернуть непустое сообщение.</p>

<p>В данном случае при заполненном поле textarea пользователю не удается переход по ссылке.</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/6-timer-interval/images/7.png" alt="start page" /></p>

<p>Этот прием может работать по разному в разных браузерах т.к. недобросовестные разработчики сайтов с целью удержания посетителей на своих страницах использовали данные приемы.</p>

<p>Также с целью безопасности в обработчике события
«onbeforeunload» не допускается создание дополнительных диалоговых окон.</p>

<h2>Cтандартные обработчики, запрет вызова стандартного обработчика.</h2>

<p>Обработчики событий по умолчанию
(стандартные обработчики)
Для некоторых событий в браузере предусмотрены
специальные стандартные обработчики, которые запускаются автоматически — без необходимости добавления их программным путем.</p>

<p>Например:</p>

<ul>
<li><p>вызов контекстного меню при нажатии правой клавиши;</p></li>
<li><p>масштабирование контента при прокрутке колеса;
мыши с нажатой кнопкой «Ctrl»</p></li>
<li><p>горячие клавиши и т.д.</p></li>
</ul>

<p>В некоторых случаях обработчики событий по умолчанию могут мешать логике работы основного содержимого страницы.</p>

<p>Такие ситуации возникают, если в интерфейсе страницы используются средства управления,
совпадающие с «зарезервированными» возможностями.</p>

<p>Рассмотрим в качестве примера следующую задачу:
создать блок, который будет менять цвет при нажатии
на нем клавиши мыши: зеленый, если нажата левая клавиша;
синий, если средняя (или колесо), красный — если правая.</p>

<p>Поскольку все три клавиши мыши посылают одно
и то же событие «mousedown», они устанавливают различные значения для свойства «which» объекта-события</p>

<p>1 — для левой клавиши</p>

<p>2 — для средней</p>

<p>3 — для правой</p>

<pre><code>&lt;div id="d1"&gt;&lt;/div&gt;
&lt;script&gt;
    window.d1.onmousedown = function(e) {
        var bgColor;
        switch( e.which ) {
            case 1:
                bgColor = "lime";
                break ;
            case 2:
                bgColor = "green";
                break;
            case 3:
                bgColor = "red";
                break ;
        }

        window.d1.style.backgroundColor = bgColor;
}
&lt;/script&gt;
</code></pre>

<p>Обратите внимание, что при нажатии правой клавиши кроме смены цвета на блоке появляется контекстное меню.</p>

<p><img src="https://webmonstr.com/media/course/frontend-js/6-timer-interval/images/8.png" alt="start page" /></p>

<p>Переопределить это поведение можно заменив
стандартный обработчик события контекстного меню
«oncontextmenu» для блока.</p>

<pre><code>window.d1.oncontextmenu = function() { return false }
</code></pre>

<p>Однако не всегда удается предотвратить стандартный обработчик с помощью return false.</p>

<p>В таких случаях необходимо воспользоваться методом prevent­Default объекта события.</p>

<pre><code>e.preventDefault();
</code></pre>

<h2>Определение нажатия клавиш клавиатуры.</h2>

<p>Определение статусов и кодов нажатия кнопок.</p>

<pre><code>ocument.body.onkeydown = function(e)    {
    console.log(e.ctrlKey);
    console.log(e.altKey);
    console.log(e.shiftKey);
    console.log(e.key);
}
</code></pre>

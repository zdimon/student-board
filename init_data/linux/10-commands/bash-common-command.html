<h2>Основные команды.</h2>

<p>Внешний вид приглашения.</p>

<pre><code>username@compname$
</code></pre>

<p>$ - не является частью команды</p>

<h2>Позиционные аргументы</h2>

<p>Обычно при использовании командной оболочки и запуске команд мы передаем им аргументы или параметры.</p>

<p>Существует механизм извлечения этих параметров из скриптов с помощью $0 $1 $2 и т.д.</p>

<p>В $0 содержится название скрипта, в $1 первый параметр и так далее.</p>

<p>в $# содержится количество параметров.</p>

<p>Часто бывает необходимо переслать параметры из одной команды в другую.</p>

<p>Для этого используются сокращения $* или $@, которые содержат все аргументы.</p>

<p>Если их заключить в двойные кавычки то вместо названий $1, $2 и т.д. будут вставлены значения параметров.</p>

<p>Пример программы testvar.</p>

<pre><code>echo $#
echo $0
echo $1
echo $3
</code></pre>

<p>Запуск.</p>

<pre><code>./testvar bash is fun
</code></pre>

<p>Проверить чем является команда.</p>

<pre><code>type pwd
type cat
type if
</code></pre>

<p><strong>echo</strong> - вывод какого нибудь значения (строки или переменной) в стандартный поток вывода.</p>

<h3>Переменные оболочки и окружения.</h3>

<p>Переменные окружения (или переменные среды или оболочки) - это набор пар ключ-значение, которые хранятся в вашем Linux и используются процессами для выполнения определенных операций. 
Окружение - это область, которую оболочка создает каждый раз при запуске сеанса, содержащего переменные, определяющие системные свойства. Например, это может быть часовой пояс в системе, пути к определенным файлам, приложения по-умолчанию, локали и многое другое. 
Переменные окружения также могут использоваться в программах оболочки или в подоболочках для выполнения различных операций.
Часто в это пространство помещают такие переменные как доступы к БД (логин пароль) или пути к важным файлам и каталогам (например к java машине).</p>

<p>Переменные имеют следующий формат</p>

<pre><code>KEY=value
</code></pre>

<p>Имена переменных чувствительны к регистру и вокруг не должно быть пробелов.</p>

<p>Переменные можно разделить на две категории:</p>

<p><strong>Переменные окружения (Environmental Variables)</strong> - это переменные, которые определены для текущей оболочки и наследуются любыми дочерними оболочками или процессами. Переменные окружения используются для передачи информации в процессы, которые порождаются из оболочки.</p>

<p>Посмотреть</p>

<pre><code>env
</code></pre>

<p><strong>Переменные оболочки (Shell Variables)</strong> - это переменные, которые содержатся исключительно в оболочке, в которой они были установлены или определены. Они часто используются для отслеживания эфемерных данных, например, текущего рабочего каталога.</p>

<p>Посмотреть</p>

<pre><code>set
</code></pre>

<p>Тут мы получим гигантский вывод, содержащий переменные и функции оболочки поэтому стоит использовать less, чтобы разделить содержимое на страницы:</p>

<pre><code>set | less
</code></pre>

<p>Для того, чтобы подставить значение переменной в строку, необходимо использовать знак $ и включить переменную в строку в двойных кавычках.</p>

<pre><code>echo "I am in $PWD dir"
</code></pre>

<p>Так же мы можем сохранить вывод командной оболочки с помощью символов $()</p>

<pre><code>MYVAR=$(pwd)
</code></pre>

<p>Сдесь команда pwd выполнится в подоболочке и вместо вывода на экран присвоит значение переменной MYVAR</p>

<h2> </h2>

<h2>Справка по командам.</h2>

<pre><code>man less
</code></pre>

<h2>Некоторые полезные переменные</h2>

<p><strong>USER</strong>: текущее имя пользователя, использующего систему</p>

<p><strong>EDITOR</strong>: какая программа запускается для редактирования файла на вашем хосте</p>

<p><strong>HOME</strong>: домашний каталог текущего пользователя</p>

<p><strong>PATH</strong>: список каталогов, разделенных двоеточиями, в которых система ищет команды</p>

<p><strong>PS1</strong>: основная строка приглашения (для определения отображения приглашения оболочки)</p>

<p><strong>PWD</strong>: текущий рабочий каталог</p>

<p>Например в переменной $SHELL храниться значение командного интерпретатора по умолчанию.</p>

<p>Посмотреть так:</p>

<pre><code>echo $SHELL
</code></pre>

<p>или так</p>

<pre><code>printenv SHELL
</code></pre>

<p>В Linux у вас есть много разных способов установки переменных окружения в зависимости от того, хотите ли вы сделать их постоянными или нет.</p>

<h2>export</h2>

<p>Создают или изменяют переменные окружения.</p>

<p>Создать и экспортировать переменную.</p>

<pre><code>export VAR="value"
</code></pre>

<p>Используя export, ваша переменная окружения будет установлена для текущего сеанса оболочки. Как следствие, если вы откроете другую оболочку или перезапустите свою систему, переменная окружения больше не будет доступна.</p>

<p>Однако она будет доступна всем процессам, которые порождены текущим терминалом (в отличии от простого присваивания)</p>

<p>Самый популярный способ постоянной установки переменных среды - это добавить их в файл .bashrc.
Файл .bashrc - это скрипт, выполняемый всякий раз, когда вы инициализируете сеанс интерактивной оболочки.</p>

<p>После добавления новых переменных перегрузить .bashrc можно командой.</p>

<pre><code>source ~/.bashrc
</code></pre>

<p>Существует еще один файл .bash_profile, который запускается при запуске login оболочек, требующих ввода логина и пароля, например ssh.</p>

<p>Чтобы установить общесистемные переменные окружения в Linux (для всех пользователей), вам нужно экспортировать переменные в файл /etc/environment.</p>

<p>Например, чтобы изменить редактор, используемый глобально, вы можете изменить переменную EDITOR в файле окружения.</p>

<pre><code>export EDITOR="vi"
</code></pre>

<p>Установить переменную окружения в одной строке.</p>

<pre><code>echo "export VAR="value"" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc
</code></pre>

<p>Удалить переменную можно командой unset.</p>

<pre><code>unset USERNAME
</code></pre>

<h2>Работа в командной строке</h2>

<p>Точка (.) - важный символ в командной строке
Linux, который обозначает текущий каталог.   </p>

<p>Символ ~ - обозначает домашний каталог. </p>

<p>Относительный путь определяется
относительно текущего каталога, а абсолютный
путь – относительно корневого каталога.</p>

<p>Клавиша Tab используется для автодополнения
команд и для вывода возможных вариантов
частично введенных команд.</p>

<p>Оболочка bash имеет несколько операторов
команд. Наиболее часто используются
следующие операторы:
&lt; &gt; | || &amp; &amp;&amp; ; ;; ()</p>

<h2>pwd</h2>

<p>Отображает текущий каталог. Аббревиатура от “print working
directory”.</p>

<h2>uname</h2>

<p>Системная информация</p>

<pre><code>uname -a
</code></pre>

<h2>История команд.</h2>

<pre><code>history N - вывод последних N строк истории
!! - запуск последней команды 
!string - Выполнение последней команды,
</code></pre>

<p>начинающейся со строки string</p>

<p>Ctrl+r - Вызывет обратный последовательный поиск
по истории.</p>

<p>Хранится история для каждого пользователя в скрытом файле .bash_history</p>

<p>Переменная окружения HISTSIZE задает
оболочке bash количество строк для сохранения
в истории.</p>

<h2>exec</h2>

<p>Запуск команды, замена текущего окружения.</p>

<h2>Некоторые полезные команды</h2>

<p>Информация о процессоре</p>

<pre><code>cat /proc/cpuinfo
lscpu
</code></pre>

<p>Свободное место на диске.</p>

<pre><code>df -h
</code></pre>

<h2>Обработка текстовых потоков.</h2>

<h3>cat</h3>

<p>Вывод файлов или стандартного ввода в stdout. С помощью этой команды можно очень просто посмотреть содержимое небольшого файла, склеить несколько файлов и многое другое.</p>

<p>Если команде передать несколько файлов, то они
выведутся вместе.</p>

<p>Синтаксис</p>

<pre><code>cat опции файл1 файл2
</code></pre>

<p>Рассмотрим основные опции:</p>

<p>-b - нумеровать только непустые строки;</p>

<p>-E - показывать символ $ в конце каждой строки;</p>

<p>-n - нумеровать все строки;</p>

<p>-s - удалять пустые повторяющиеся строки;</p>

<p>-T - отображать табуляции в виде ^I;</p>

<p>-h - отобразить справку;</p>

<p>-v - версия утилиты.</p>

<p>Пример вывод лога с нумерацией строк</p>

<pre><code>cat /var/log/nginx/access.log.1 -b
</code></pre>

<p>Пример ввода с клавиатуры и перенаправления в файл</p>

<pre><code>cat &gt; test
</code></pre>

<p>Для прекращения ввода нажимаем ctrl+D</p>

<p>Объединение файлов.</p>

<pre><code>cat file1 file2 &gt; file3
</code></pre>

<h2>cut</h2>

<p>Программа cut используется для выборки
отдельных полей из строк файла. Выборка
полей производиться заданием разделителей.</p>

<p>Команда cut позволяет вам вырезать данные по символам, по полю или по столбцу.</p>

<p>-c - символы для извлечения (позиция символа)</p>

<p>-d - разделитель полей (по умолчанию табуляция)</p>

<p>-f - поля для извлечения </p>

<p>Выборка первого столбца с разделитем пробел.</p>

<pre><code>cut -d ' ' -f 1 /var/log/nginx/access.log.1
</code></pre>

<p>Вывести всех пользователей в системе.</p>

<pre><code>cut -d: -f1 /etc/passwd
</code></pre>

<h2>Фильтры текстовых потоков.</h2>

<p><strong>head</strong> - отображает первые строки</p>

<p><strong>tail</strong> - отображает последние строки.</p>

<p>Отобразить последние строки интерактивно.</p>

<pre><code>tail -f /var/log/nginx/access.log.1
</code></pre>

<h2>sed</h2>

<p>Утилиту sed называют потоковым текстовым редактором. В интерактивных текстовых редакторах, наподобие nano, с текстами работают, используя клавиатуру, редактируя файлы, добавляя, удаляя или изменяя тексты. Sed позволяет редактировать потоки данных, основываясь на заданных разработчиком наборах правил.</p>

<p>Схема вызова.</p>

<pre><code>sed options file
</code></pre>

<p>По умолчанию sed применяет указанные правила к стандартному потоку ввода.</p>

<pre><code>echo "blablabla" | sed 's/bla/mla/'
echo "blablabla" | sed 's/bla/mla/g'
</code></pre>

<p>Маркеры</p>

<p>s - substitute замена</p>

<p>g - глобально</p>

<p>i - без учета регистра</p>

<p>Параметры.</p>

<p>-i - редактировать файл</p>

<p>Передаем команде файл.</p>

<pre><code>sed 's/test/another test' ./myfile
</code></pre>

<p>Sed не меняет данные в обрабатываемом файле (если не задан -i). Редактор читает файл, обрабатывает прочитанное, и отправляет то, что получилось, в STDOUT.</p>

<p>Для выполнения нескольких действий с данными, используйте ключ -e при вызове sed. Например, вот как организовать замену двух фрагментов текста:</p>

<pre><code>sed -e 's/This/That/; s/test/another test/' ./myfile
</code></pre>

<p>Воспользуемся флагом w, который позволяет сохранить результаты обработки текста в файл:</p>

<pre><code>sed 's/test/another test/w output' myfile
</code></pre>

<p>Можно вызвать команду замены так, чтобы файл был обработан начиная с некоей строки и до конца:</p>

<pre><code>sed '2,$s/test/another test/' myfile
</code></pre>

<p>Удаление строк.</p>

<pre><code>sed '3d' myfile
</code></pre>

<p>удаляем диапазон строк</p>

<pre><code>sed '2,3d' myfile
sed '3,$d' myfile
</code></pre>

<p>Удаление строк по шаблону.</p>

<pre><code>sed '/test/d' myfile
</code></pre>

<p>С помощью sed можно вставлять данные в текстовый поток, используя команды i и a:</p>

<p>Команда i добавляет новую строку перед заданной.</p>

<p>Команда a добавляет новую строку после заданной.</p>

<pre><code>echo "Another test" | sed 'i\First test '
</code></pre>

<p>Указание опорной строки.</p>

<pre><code>sed '2i\This is the inserted line.' myfile
</code></pre>

<p>Замена строк.</p>

<pre><code>sed '3c\This is a modified line.' myfile
</code></pre>

<p>Команда r позволяет вставлять в поток данные из указанного файла. </p>

<pre><code>sed '3r newfile' myfile
</code></pre>

<h1>Анализ</h1>

<h2>wc - подсчет</h2>

<p>Ключи команды wc</p>

<p>-c - Количество символов в файле</p>

<p>-l - Количество переводов строк</p>

<p>-w - Количество слов</p>

<pre><code>wc filename
</code></pre>

<h2>nl</h2>

<p>Нумерует строки в файле.</p>

<h2>paste</h2>

<p>Выводит построчно содержимое двух файлов бок о бок для стравнения или слияния.</p>

<h2>join</h2>

<p>Объеденяет строки в содержимом двух файлов.</p>

<pre><code>join file1.txt file2.txt &gt; newjoinfile.txt
</code></pre>

<h2>sort</h2>

<p>Ее можно использовать для сортировки текста из одного или нескольких файлов или c помощью нее может быть выполнена сортировка вывода linux для какой-либо команды. </p>

<p>Синтаксис</p>

<pre><code>sort опции файл
</code></pre>

<p>Вот несколько принципов, по которым команда sort linux сортирует строки:</p>

<p>Строки с цифрами размещаются выше других строк</p>

<p>Строки, начинающиеся с букв нижнего регистра размещаются выше</p>

<p>Сортировка выполняется в соответствии алфавиту</p>

<p>Строки сначала сортируются по алфавиту, а уже вторично по другим правилам.</p>

<p>ОПЦИИ</p>

<p>-b - не учитывать пробелы</p>

<p>-d - использовать для сортировки только буквы и цифры</p>

<p>-i - сортировать только по ASCII символах</p>

<p>-n - сортировка строк linux по числовому значению</p>

<p>-r - сортировать в обратном порядке</p>

<p>-с - проверить был ли отсортирован файл</p>

<p>-o - вывести результат в файл</p>

<p>-u - игнорировать повторяющиеся строки</p>

<p>-m - объединение ранее отсортированных файлов</p>

<p>-k - указать поле по которому нужно сортировать строки, если не задано, сортировка выполняется по всей строке.</p>

<p>-f - использовать в качестве разделителя полей ваш символ вместо пробела.</p>

<p>Отсортируем файлы по дате создания</p>

<pre><code>ls -l | sort -k8
</code></pre>

<p>по числовому значению (размеру)</p>

<h2>Примеры.</h2>

<p>Вывести наиболее большие файлы и директории.</p>

<pre><code>du -a /var | sort -n -r | head -n 10

du -hsx * | sort -rh | head -10
</code></pre>

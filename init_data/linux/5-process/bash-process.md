# Управление процессами.

Процесс в Linux (как и в UNIX) - это программа, которая выполняется в отдельном виртуальном адресном пространстве.

Каждый процесс выполняется в собственном виртуальном адресном пространстве, т.е. процессы защищены друг от друга и крах одного процесса никак не повлияет на другие выполняющиеся процессы и на всю систему в целом. Один процесс не может прочитать что-либо из памяти (или записать в нее) другого процесса без "разрешения" на то другого процесса. Санкционированные взаимодействия между процессами допускаются системой.

Linux поддерживает параллельное (или квазипараллельного при наличии только одного процессора) выполнение процессов пользователя. 

Ядро предоставляет системные вызовы для создания новых процессов и для управления порожденными процессами. 

Любая программа может начать выполняться только если другой процесс ее запустит или произойдет какое-то прерывание (например, прерывание внешнего устройства).

В связи с развитием SMP (Symmetric Multiprocessor Architectures) в ядро Linux был внедрен механизм нитей или потоков управления (threads). Нить - это процесс, который выполняется в виртуальной памяти, используемой вместе с другими нитями процесса, который обладает отдельной виртуальной памятью.

Каждый процесс реагирует на сигналы и, естественно, может установить собственную реакцию на сигналы, производимые операционной системой.

Сигнал - способ информирования процесса ядром о происшествии какого-то события.

Примеры сигналов:

окончание порожденного процесса
возникновение исключительной ситуации
сигналы, поступающие от пользователя при нажатии определенных клавиш.

Для создания процессов используются два системных вызова: fork() и exec. fork() создает новое адресное пространство, которое полностью идентично адресному пространству основного процесса. После выполнения этого системного вызова мы получаем два абсолютно одинаковых процесса - основной и порожденный. Функция fork() возвращает PID (Process ID - идентификатор порожденного процесса) - в основном. PID - это целое число. 

С помощью команды kill можно сгенерировать сигнал завершения процесса и передать его конкретному процессу по его PID. 

Когда вы выполняете команду "kill", то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение.

Вы можете просмотреть все сигналы с помощью команды:

    kill -l
    
Синтаксис использования "kill":

    kill [сигнал или опция] PID
    
Сигнал по умолчанию (если он не задан) - SIGTERM. Если он не помогает, для принудительного завершения процесса можно использовать следующие варианты:

    $ kill SIGKILL PID
    $ kill -9 PID
    
Если вы не знаете точно PID приложения, просто запустите команду:

    ps ux
    
## top

Команда ps позволяет сделать как бы "моментальный снимок" процессов, запущенных в системе. В отличие от ps команда top отображает состояние процессов и их активность "в реальном режиме времени".    

Полезные комбинации.

<Shift>+<N> — сортировка по PID;
<Shift>+<A> — сортировать процессы по возрасту;
<Shift>+<P> — сортировать процессы по использованию ЦПУ;
<Shift>+<M> — сортировать процессы по использованию памяти;
<Shift>+<T> — сортировка по времени выполнения.

    
## Pkill
    
Команда "pkill" позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID вы теперь можете завершить приложение, введя имя его процесса. Например, для завершения работы Firefox просто введите команду:

    pkill firefox

## Killall
        
Killall также использует имя процесса вместо PID и завершает все экземпляры процесса с этим именем. Например, если вы запустили несколько экземпляров Firefox, вы можете завершить их все с помощью команды:

$ killall firefox
   
Запустить программу в фоновом режиме можно с помощью конструкции <команда> &     


Например такой скрипт timer.py.

    import time

    while True:
        time.sleep(1)
        print(time.time())


Может быть запущен в фоновом режиме командой:

    python timer.py &






    

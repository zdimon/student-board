<h1>Управление процессами.</h1>

<p>Процесс в Linux (как и в UNIX) - это программа, которая выполняется в отдельном виртуальном адресном пространстве.</p>

<p>Каждый процесс выполняется в собственном виртуальном адресном пространстве, т.е. процессы защищены друг от друга и крах одного процесса никак не повлияет на другие выполняющиеся процессы и на всю систему в целом. Один процесс не может прочитать что-либо из памяти (или записать в нее) другого процесса без "разрешения" на то другого процесса. Санкционированные взаимодействия между процессами допускаются системой.</p>

<p>Linux поддерживает параллельное (или квазипараллельного при наличии только одного процессора) выполнение процессов пользователя. </p>

<p>Ядро предоставляет системные вызовы для создания новых процессов и для управления порожденными процессами. </p>

<p>Любая программа может начать выполняться только если другой процесс ее запустит или произойдет какое-то прерывание (например, прерывание внешнего устройства).</p>

<p>В связи с развитием SMP (Symmetric Multiprocessor Architectures) в ядро Linux был внедрен механизм нитей или потоков управления (threads). Нить - это процесс, который выполняется в виртуальной памяти, используемой вместе с другими нитями процесса, который обладает отдельной виртуальной памятью.</p>

<p>Каждый процесс реагирует на сигналы и, естественно, может установить собственную реакцию на сигналы, производимые операционной системой.</p>

<p>Сигнал - способ информирования процесса ядром о происшествии какого-то события.</p>

<p>Примеры сигналов:</p>

<p>окончание порожденного процесса
возникновение исключительной ситуации
сигналы, поступающие от пользователя при нажатии определенных клавиш.</p>

<p>Для создания процессов используются два системных вызова: fork() и exec. fork() создает новое адресное пространство, которое полностью идентично адресному пространству основного процесса. После выполнения этого системного вызова мы получаем два абсолютно одинаковых процесса - основной и порожденный. Функция fork() возвращает PID (Process ID - идентификатор порожденного процесса) - в основном. PID - это целое число. </p>

<p>С помощью команды kill можно сгенерировать сигнал завершения процесса и передать его конкретному процессу по его PID. </p>

<p>Когда вы выполняете команду "kill", то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение.</p>

<p>Вы можете просмотреть все сигналы с помощью команды:</p>

<pre><code>kill -l
</code></pre>

<p>Синтаксис использования "kill":</p>

<pre><code>kill [сигнал или опция] PID
</code></pre>

<p>Сигнал по умолчанию (если он не задан) - SIGTERM. Если он не помогает, для принудительного завершения процесса можно использовать следующие варианты:</p>

<pre><code>$ kill SIGKILL PID
$ kill -9 PID
</code></pre>

<p>Если вы не знаете точно PID приложения, просто запустите команду:</p>

<pre><code>ps ux
</code></pre>

<h2>top</h2>

<p>Команда ps позволяет сделать как бы "моментальный снимок" процессов, запущенных в системе. В отличие от ps команда top отображает состояние процессов и их активность "в реальном режиме времени".    </p>

<p>Полезные комбинации.</p>

<p><Shift>+<N> — сортировка по PID;
<Shift>+<A> — сортировать процессы по возрасту;
<Shift>+<P> — сортировать процессы по использованию ЦПУ;
<Shift>+<M> — сортировать процессы по использованию памяти;
<Shift>+<T> — сортировка по времени выполнения.</p>

<h2>Pkill</h2>

<p>Команда "pkill" позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID вы теперь можете завершить приложение, введя имя его процесса. Например, для завершения работы Firefox просто введите команду:</p>

<pre><code>pkill firefox
</code></pre>

<h2>Killall</h2>

<p>Killall также использует имя процесса вместо PID и завершает все экземпляры процесса с этим именем. Например, если вы запустили несколько экземпляров Firefox, вы можете завершить их все с помощью команды:</p>

<p>$ killall firefox</p>

<p>Запустить программу в фоновом режиме можно с помощью конструкции &lt;команда&gt; &amp;     </p>

<p>Например такой скрипт timer.py.</p>

<pre><code>import time

while True:
    time.sleep(1)
    print(time.time())
</code></pre>

<p>Может быть запущен в фоновом режиме командой:</p>

<pre><code>python timer.py &amp;
</code></pre>

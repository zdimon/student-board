# Решение типовых проблем на BASH.

Любой bash-скрипт должен начинаться со строки:

    #!/bin/bash
   
## Вы хотите знать значение всех знаков пунктуации в консоле.

Внешний вид консоли во многом зависит от ОС.

Разберем основные знаки для ОС Linux.

$ - в конце командной строки означает что вы залогинены как обычный пользователь # - как суперпользователь.

~ - обозначает домашнюю директорию.

## Вы хотите знать в какой директории находитесь.

Команда pwd.

У нее есть 2 аргумента -L и -P которые будут показывать разные каталоги если вы используете символическую ссылку.


## Вы хотите найти и запустить определенную команду в BASH

Все пути к исполняемым командам находятся в переменной PATH.

Существует ряд полезных комманд.

**type** - покажет тип команды (файл, встроенная команда или ключевое слово) проведя поиск в PATH

    $ type ls
    ls is aliased to `ls -F -h'

**man** - документация по любой комманде.

    man ls

**apropos и whatis** - (apropos переводится как кстати) обе команды производят контекстный поиск по ключевой фразе (whatis ищет полное совпадение)

**compgen** - выводит список всех ключевых слов, команд и функций языка.

-с - комманды

-b - функции

-k - ключевые слова


## Необходимо вывести более подробную информацию о файле.

Используем ls, stat, file или find комманды.

    ls -l /tmp/sample_file

    stat /tmp/sample_file

    file /tmp/sample_file

Ключи для ls

-a - отображает скрытые файлы, начинающиеся с .

-l - длинный формат

-R - рекурсия по поддиректориям

-S - сортирует по размеру

Для того, чтобы вывести файлы по шаблону нужно использовать -d

    ls -d .*
    ls -d .r*



## Необходимо в строку поместить переменную наряду со знаком $

Используется экранирование.

    echo "$USER won't pay \$5 for coffee."

## Необходимо переопределить существующую комманду.

Переопределить можно в .bashrc

    cd () {
        builtin cd "$@"
        echo "$OLDPWD --> $PWD"
    }

$@ - зарезервированная переменная в которой содержаться все переменные командной строки.

### Список зарезервированных переменных.

$UID - ...содержит реальный идентификатор, который устанавливается только при логине.

$FUNCNAME - имя текущей функции в скрипте.

$GROUPS - массив групп к которым принадлежит текущий пользователь

$HOME - домашний каталог пользователя

$HOSTNAME - ваш hostname

$HOSTTYPE - архитектура машины.

$LC_CTYPE - внутренняя переменная, котороя определяет кодировку символов

$OLDPWD - прежний рабочий каталог

$OSTYPE - тип ОС

$PATH - путь поиска программ

$PPID - идентификатор родительского процесса

$SECONDS - время работы скрипта(в сек.)

$# - общее количество параметров переданных скрипту

$* - все аргументы переданыне скрипту(выводятся в строку)

$@ - тоже самое, что и предыдущий, но параметры выводятся в столбик

$! - PID последнего запущенного в фоне процесса

$$ - PID самого скрипта

**$-** - строка, содержащая все текущие флаги коммандной оболочки.

К примеру флаг i указывает об интерактивном режиме.

Можно проверить интерактивность в программе так.

    #!/usr/bin/env bash

    case "$-" in
        *i*) # Code for interactive shell here
        ;;
        *)
        # Code for noninteractive shell here
        ;;
    esac

## Вам необходим более полный контроль над форматированием строки.

Используйте оператор printf который работает так же как в С++

    printf '%s = %d\n' Lines $LINES

    printf '%-10.10s = %4.2f\n' 'Gigahertz' 1.92735






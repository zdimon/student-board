<h1>Решение типовых проблем на BASH.</h1>

<p>Любой bash-скрипт должен начинаться со строки:</p>

<pre><code>#!/bin/bash
</code></pre>

<h2>Вы хотите знать значение всех знаков пунктуации в консоле.</h2>

<p>Внешний вид консоли во многом зависит от ОС.</p>

<p>Разберем основные знаки для ОС Linux.</p>

<p>$ - в конце командной строки означает что вы залогинены как обычный пользователь # - как суперпользователь.</p>

<p>~ - обозначает домашнюю директорию.</p>

<h2>Вы хотите знать в какой директории находитесь.</h2>

<p>Команда pwd.</p>

<p>У нее есть 2 аргумента -L и -P которые будут показывать разные каталоги если вы используете символическую ссылку.</p>

<h2>Вы хотите найти и запустить определенную команду в BASH</h2>

<p>Все пути к исполняемым командам находятся в переменной PATH.</p>

<p>Существует ряд полезных комманд.</p>

<p><strong>type</strong> - покажет тип команды (файл, встроенная команда или ключевое слово) проведя поиск в PATH</p>

<pre><code>$ type ls
ls is aliased to `ls -F -h'
</code></pre>

<p><strong>man</strong> - документация по любой комманде.</p>

<pre><code>man ls
</code></pre>

<p><strong>apropos и whatis</strong> - (apropos переводится как кстати) обе команды производят контекстный поиск по ключевой фразе (whatis ищет полное совпадение)</p>

<p><strong>compgen</strong> - выводит список всех ключевых слов, команд и функций языка.</p>

<p>-с - комманды</p>

<p>-b - функции</p>

<p>-k - ключевые слова</p>

<h2>Необходимо вывести более подробную информацию о файле.</h2>

<p>Используем ls, stat, file или find комманды.</p>

<pre><code>ls -l /tmp/sample_file

stat /tmp/sample_file

file /tmp/sample_file
</code></pre>

<p>Ключи для ls</p>

<p>-a - отображает скрытые файлы, начинающиеся с .</p>

<p>-l - длинный формат</p>

<p>-R - рекурсия по поддиректориям</p>

<p>-S - сортирует по размеру</p>

<p>Для того, чтобы вывести файлы по шаблону нужно использовать -d</p>

<pre><code>ls -d .*
ls -d .r*
</code></pre>

<h2>Необходимо в строку поместить переменную наряду со знаком $</h2>

<p>Используется экранирование.</p>

<pre><code>echo "$USER won't pay \$5 for coffee."
</code></pre>

<h2>Необходимо переопределить существующую комманду.</h2>

<p>Переопределить можно в .bashrc</p>

<pre><code>cd () {
    builtin cd "$@"
    echo "$OLDPWD --&gt; $PWD"
}
</code></pre>

<p>$@ - зарезервированная переменная в которой содержаться все переменные командной строки.</p>

<h3>Список зарезервированных переменных.</h3>

<p>$UID - ...содержит реальный идентификатор, который устанавливается только при логине.</p>

<p>$FUNCNAME - имя текущей функции в скрипте.</p>

<p>$GROUPS - массив групп к которым принадлежит текущий пользователь</p>

<p>$HOME - домашний каталог пользователя</p>

<p>$HOSTNAME - ваш hostname</p>

<p>$HOSTTYPE - архитектура машины.</p>

<p>$LC_CTYPE - внутренняя переменная, котороя определяет кодировку символов</p>

<p>$OLDPWD - прежний рабочий каталог</p>

<p>$OSTYPE - тип ОС</p>

<p>$PATH - путь поиска программ</p>

<p>$PPID - идентификатор родительского процесса</p>

<p>$SECONDS - время работы скрипта(в сек.)</p>

<p>$# - общее количество параметров переданных скрипту</p>

<p>$* - все аргументы переданыне скрипту(выводятся в строку)</p>

<p>$@ - тоже самое, что и предыдущий, но параметры выводятся в столбик</p>

<p>$! - PID последнего запущенного в фоне процесса</p>

<p>$$ - PID самого скрипта</p>

<p><strong>$-</strong> - строка, содержащая все текущие флаги коммандной оболочки.</p>

<p>К примеру флаг i указывает об интерактивном режиме.</p>

<p>Можно проверить интерактивность в программе так.</p>

<pre><code>#!/usr/bin/env bash

case "$-" in
    *i*) # Code for interactive shell here
    ;;
    *)
    # Code for noninteractive shell here
    ;;
esac
</code></pre>

<h2>Вам необходим более полный контроль над форматированием строки.</h2>

<p>Используйте оператор printf который работает так же как в С++</p>

<pre><code>printf '%s = %d\n' Lines $LINES

printf '%-10.10s = %4.2f\n' 'Gigahertz' 1.92735
</code></pre>
